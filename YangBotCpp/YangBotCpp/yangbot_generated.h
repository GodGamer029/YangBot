// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_YANGBOT_YANGBOT_CPP_H_
#define FLATBUFFERS_GENERATED_YANGBOT_YANGBOT_CPP_H_

#include "flatbuffers/flatbuffers.h"

namespace yangbot {
	namespace cpp {

		struct FlatVec3;

		struct FBSCarData;

		struct FlatRay;

		struct CarCollisionInfo;

		MANUALLY_ALIGNED_STRUCT(4) FlatVec3 FLATBUFFERS_FINAL_CLASS {
		private:
			float x_;
			float y_;
			float z_;

		public:
			FlatVec3() {
				memset(this, 0, sizeof(FlatVec3));
			}
			FlatVec3(float _x, float _y, float _z)
				: x_(flatbuffers::EndianScalar(_x)),
				y_(flatbuffers::EndianScalar(_y)),
				z_(flatbuffers::EndianScalar(_z)) {
			}
			float x() const {
				return flatbuffers::EndianScalar(x_);
			}
			float y() const {
				return flatbuffers::EndianScalar(y_);
			}
			float z() const {
				return flatbuffers::EndianScalar(z_);
			}
		};
		STRUCT_END(FlatVec3, 12);

		MANUALLY_ALIGNED_STRUCT(4) FlatRay FLATBUFFERS_FINAL_CLASS {
		private:
			FlatVec3 start_;
			FlatVec3 direction_;

		public:
			FlatRay() {
				memset(this, 0, sizeof(FlatRay));
			}
			FlatRay(const FlatVec3 & _start, const FlatVec3 & _direction)
				: start_(_start),
				direction_(_direction) {
			}
			const FlatVec3& start() const {
				return start_;
			}
			const FlatVec3& direction() const {
				return direction_;
			}
		};
		STRUCT_END(FlatRay, 24);

		struct FBSCarData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
			enum {
				VT_POSITION = 4,
				VT_VELOCITY = 6,
				VT_ANGULARVELOCITY = 8,
				VT_EULERROTATION = 10,
				VT_ONGROUND = 12,
				VT_ELAPSEDSECONDS = 14
			};
			const FlatVec3* position() const {
				return GetStruct<const FlatVec3*>(VT_POSITION);
			}
			const FlatVec3* velocity() const {
				return GetStruct<const FlatVec3*>(VT_VELOCITY);
			}
			const FlatVec3* angularVelocity() const {
				return GetStruct<const FlatVec3*>(VT_ANGULARVELOCITY);
			}
			const FlatVec3* eulerRotation() const {
				return GetStruct<const FlatVec3*>(VT_EULERROTATION);
			}
			bool onGround() const {
				return GetField<uint8_t>(VT_ONGROUND, 0) != 0;
			}
			float elapsedSeconds() const {
				return GetField<float>(VT_ELAPSEDSECONDS, 0.0f);
			}
			bool Verify(flatbuffers::Verifier& verifier) const {
				return VerifyTableStart(verifier) &&
					VerifyField<FlatVec3>(verifier, VT_POSITION) &&
					VerifyField<FlatVec3>(verifier, VT_VELOCITY) &&
					VerifyField<FlatVec3>(verifier, VT_ANGULARVELOCITY) &&
					VerifyField<FlatVec3>(verifier, VT_EULERROTATION) &&
					VerifyField<uint8_t>(verifier, VT_ONGROUND) &&
					VerifyField<float>(verifier, VT_ELAPSEDSECONDS) &&
					verifier.EndTable();
			}
		};

		struct FBSCarDataBuilder {
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t start_;
			void add_position(const FlatVec3* position) {
				fbb_.AddStruct(FBSCarData::VT_POSITION, position);
			}
			void add_velocity(const FlatVec3* velocity) {
				fbb_.AddStruct(FBSCarData::VT_VELOCITY, velocity);
			}
			void add_angularVelocity(const FlatVec3* angularVelocity) {
				fbb_.AddStruct(FBSCarData::VT_ANGULARVELOCITY, angularVelocity);
			}
			void add_eulerRotation(const FlatVec3* eulerRotation) {
				fbb_.AddStruct(FBSCarData::VT_EULERROTATION, eulerRotation);
			}
			void add_onGround(bool onGround) {
				fbb_.AddElement<uint8_t>(FBSCarData::VT_ONGROUND, static_cast<uint8_t>(onGround), 0);
			}
			void add_elapsedSeconds(float elapsedSeconds) {
				fbb_.AddElement<float>(FBSCarData::VT_ELAPSEDSECONDS, elapsedSeconds, 0.0f);
			}
			explicit FBSCarDataBuilder(flatbuffers::FlatBufferBuilder& _fbb)
				: fbb_(_fbb) {
				start_ = fbb_.StartTable();
			}
			FBSCarDataBuilder& operator=(const FBSCarDataBuilder&);
			flatbuffers::Offset<FBSCarData> Finish() {
				const auto end = fbb_.EndTable(start_);
				auto o = flatbuffers::Offset<FBSCarData>(end);
				return o;
			}
		};

		inline flatbuffers::Offset<FBSCarData> CreateFBSCarData(
			flatbuffers::FlatBufferBuilder& _fbb,
			const FlatVec3* position = 0,
			const FlatVec3* velocity = 0,
			const FlatVec3* angularVelocity = 0,
			const FlatVec3* eulerRotation = 0,
			bool onGround = false,
			float elapsedSeconds = 0.0f) {
			FBSCarDataBuilder builder_(_fbb);
			builder_.add_elapsedSeconds(elapsedSeconds);
			builder_.add_eulerRotation(eulerRotation);
			builder_.add_angularVelocity(angularVelocity);
			builder_.add_velocity(velocity);
			builder_.add_position(position);
			builder_.add_onGround(onGround);
			return builder_.Finish();
		}

		struct CarCollisionInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
			enum {
				VT_CARDATA = 4,
				VT_IMPACT = 6
			};
			const FBSCarData* carData() const {
				return GetPointer<const FBSCarData*>(VT_CARDATA);
			}
			const FlatRay* impact() const {
				return GetStruct<const FlatRay*>(VT_IMPACT);
			}
			bool Verify(flatbuffers::Verifier& verifier) const {
				return VerifyTableStart(verifier) &&
					VerifyOffset(verifier, VT_CARDATA) &&
					verifier.VerifyTable(carData()) &&
					VerifyField<FlatRay>(verifier, VT_IMPACT) &&
					verifier.EndTable();
			}
		};

		struct CarCollisionInfoBuilder {
			flatbuffers::FlatBufferBuilder& fbb_;
			flatbuffers::uoffset_t start_;
			void add_carData(flatbuffers::Offset<FBSCarData> carData) {
				fbb_.AddOffset(CarCollisionInfo::VT_CARDATA, carData);
			}
			void add_impact(const FlatRay* impact) {
				fbb_.AddStruct(CarCollisionInfo::VT_IMPACT, impact);
			}
			explicit CarCollisionInfoBuilder(flatbuffers::FlatBufferBuilder& _fbb)
				: fbb_(_fbb) {
				start_ = fbb_.StartTable();
			}
			CarCollisionInfoBuilder& operator=(const CarCollisionInfoBuilder&);
			flatbuffers::Offset<CarCollisionInfo> Finish() {
				const auto end = fbb_.EndTable(start_);
				auto o = flatbuffers::Offset<CarCollisionInfo>(end);
				return o;
			}
		};

		inline flatbuffers::Offset<CarCollisionInfo> CreateCarCollisionInfo(
			flatbuffers::FlatBufferBuilder& _fbb,
			flatbuffers::Offset<FBSCarData> carData = 0,
			const FlatRay* impact = 0) {
			CarCollisionInfoBuilder builder_(_fbb);
			builder_.add_impact(impact);
			builder_.add_carData(carData);
			return builder_.Finish();
		}

		inline const yangbot::cpp::CarCollisionInfo* GetCarCollisionInfo(const void* buf) {
			return flatbuffers::GetRoot<yangbot::cpp::CarCollisionInfo>(buf);
		}

		inline const yangbot::cpp::CarCollisionInfo* GetSizePrefixedCarCollisionInfo(const void* buf) {
			return flatbuffers::GetSizePrefixedRoot<yangbot::cpp::CarCollisionInfo>(buf);
		}

		inline bool VerifyCarCollisionInfoBuffer(
			flatbuffers::Verifier& verifier) {
			return verifier.VerifyBuffer<yangbot::cpp::CarCollisionInfo>(nullptr);
		}

		inline bool VerifySizePrefixedCarCollisionInfoBuffer(
			flatbuffers::Verifier& verifier) {
			return verifier.VerifySizePrefixedBuffer<yangbot::cpp::CarCollisionInfo>(nullptr);
		}

		inline void FinishCarCollisionInfoBuffer(
			flatbuffers::FlatBufferBuilder& fbb,
			flatbuffers::Offset<yangbot::cpp::CarCollisionInfo> root) {
			fbb.Finish(root);
		}

		inline void FinishSizePrefixedCarCollisionInfoBuffer(
			flatbuffers::FlatBufferBuilder& fbb,
			flatbuffers::Offset<yangbot::cpp::CarCollisionInfo> root) {
			fbb.FinishSizePrefixed(root);
		}

	}  // namespace cpp
}  // namespace yangbot

#endif  // FLATBUFFERS_GENERATED_YANGBOT_YANGBOT_CPP_H_
